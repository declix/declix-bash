import "package://pkl.declix.org/pkl-declix@0.6.0#/declix.pkl"
import "package://pkl.declix.org/pkl-declix@0.6.0#/apt/apt.pkl"
import "package://pkl.declix.org/pkl-declix@0.6.0#/fs/fs.pkl"
import "package://pkl.declix.org/pkl-declix@0.6.0#/systemd/systemd.pkl"
import "package://pkl.declix.org/pkl-declix@0.6.0#/user/user.pkl"

import "pkl:base"
import "pkl:math"

function generate(resources): String = genScript(toGens(resources)).join("\n")

function gen(resource: Any): Gen = toGen(resource)

local commonSh = read("src/common.sh");

local function genScript(gens: Listing<Gen>): Listing<String> = new Listing {
    // script header
    """
    #!/usr/bin/env bash
    set -eu
    set -o pipefail
    """
    commonSh.text
    // generate implementation functions
    for (gen in gens) {
        ...gen.aux
        """
        function \(gen.functionName)() {
            local action=$1
        """
        ...gen.result
        "}"
    }
    // generate check
    """
    check() {
        local status
    """
        for (gen in gens) {
            """
                status=$(\(gen.functionName) "check")
                printf "%-60s %s\\n" "\(gen.id)" "$status"
            """
        }
    "}"
    // generate diff
    """
    diff() {
        local status
    """
        for (gen in gens) {
            """
                status=$(\(gen.functionName) "diff")
                if [ -n "$status" ]; then
                    printf "\(gen.id)\\n" 
                    printf "$status\\n"
                fi
            """
        }
    "}"
    // generate apply
    """
    apply() {
        local status
    """
        for (gen in gens) {
            """
                status=$(\(gen.functionName) "apply")
                printf "%-60s %s\\n" "\(gen.id)" "$status"
            """
        }
    "}"
    // main script entrypoint
    """
    if [ $# -eq 0 ]; then
        echo "Usage: $0 {check|diff|apply}"
        exit 1
    fi
    
    action=$1
    case "$action" in
        check)
            check
            ;;
        apply)
            apply
            ;;
        diff)
            diff
            ;;
        *)
            echo "Usage: $0 {check|diff|apply}"
            exit 1
            ;;
    esac
    """
}

function toGens(resources): Listing<Gen> = 
    if (resources is Listing)
        resources.toList().map((r)->toGen(r)).toListing()
    else
        resources.toList().map((r)->toGen(r)).toListing()

function toGen(resource: Any): Gen = 
    if (resource is apt.Package) 
        new AptPackageGen { pkg = resource.toDynamic() }
    else if (resource is fs.File) 
        new FsFileGen { file = resource.toDynamic() }
    else if (resource is fs.Dir) 
        new FsDirGen { dir = resource.toDynamic() }
    else if (resource is systemd.Unit)
        new SystemdUnitGen { unit = resource.toDynamic() }
    else if (resource is user.User)
        new UserGen { user = resource.toDynamic() }
    else if (resource is user.Group)
        new GroupGen { group = resource.toDynamic() }
    else if (resource.type == "apt")
        new AptPackageGen { pkg = resource }
    else if (resource.type == "file" || resource.type == "fs:file")
        new FsFileGen { file = resource }
    else if (resource.type == "dir" || resource.type == "fs:dir")
        new FsDirGen { dir = resource }
    else if (resource.type == "systemd")
        new SystemdUnitGen { unit = resource }
    else if (resource.type == "user")
        new UserGen { user = resource }
    else if (resource.type == "group")
        new GroupGen { group = resource }
    else 
        throw("unsupported resource type: \(resource.type)")

abstract class Gen {
    fixed id: String

    fixed result: Listing<String>

    aux: Listing<String> = new Listing {}

    fixed functionName: String = "_" + id.replaceAll(Regex(#"[^0-9a-zA-Z_]"#), "__")
}

// each resource must define function body with following arguments:
// - $action = "check" | "apply"

class AptPackageGen extends Gen {
    pkg: Dynamic
    fixed id = pkg.id

    fixed result = new Listing { 
        if (pkg.state == "installed")
            """
            __apt_installed "$action" "\(pkg.name)" "\(pkg.updateBeforeInstall)"
            """ 
        else if (pkg.state == "missing")
            """
            __apt_missing "$action" "\(pkg.name)"
            """ 
        else
            throw("Unsupported APT package state: \(pkg.state)")
    }
}

// toList().filter((cmd) -> cmd != "").join("\n")

class FsFileGen extends Gen {
    file: Dynamic
    fixed id = file.id

    fixed result = new Listing { 
        if (!file.state.hasProperty("content") && !file.state.hasProperty("owner")) 
            """
            __file_missing "$action" "\(file.path)"
            """ 
        else
            let (state = file.state)
            """
            __file_present "$action" "\(file.path)" "\(contentSha256(state.content))" "\(state.owner)" "\(state.group)" "\(state.permissions)"
            """ 
    }

    aux = if (file.state.hasProperty("content")) new Listing {
        let (content = file.state.content)
        """
        function __content__\(content.sha256)() {
            local content="\(encodeContentBase64(content))"
            echo $content | base64 --decode
        }
        """
    } else new Listing { }
}

class FsDirGen extends Gen {
    dir: Dynamic
    fixed id = dir.id

    fixed result = new Listing { 
        if (!dir.state.hasProperty("owner") && !dir.state.hasProperty("group")) 
            """
            __dir_missing "$action" "\(dir.path)"
            """ 
        else
            let (state = dir.state)
            """
            __dir_present "$action" "\(dir.path)" "\(state.owner)" "\(state.group)" "\(state.permissions)"
            """ 
    }
}

class SystemdUnitGen extends Gen {
    unit: Dynamic
    fixed id = unit.id
    
    fixed result = new Listing {
        let (stateType = 
            // Check for type property first if available
            if (unit.state.hasProperty("type")) unit.state.type
            // Fallback to property-based detection for backwards compatibility
            else if (unit.state.hasProperty("active") && unit.state.hasProperty("autoStart")) "enabled"
            else if (unit.state.hasProperty("stopIfRunning")) "disabled"
            else if (unit.state.hasProperty("daemonReload")) "missing" // default for daemonReload-only
            else "missing"
        )
        let (daemonReload = if (unit.state.hasProperty("daemonReload")) unit.state.daemonReload else false)
        let (active = if (unit.state.hasProperty("active")) unit.state.active else false)
        let (autoStart = if (unit.state.hasProperty("autoStart")) unit.state.autoStart else false)
        let (stopIfRunning = if (unit.state.hasProperty("stopIfRunning")) unit.state.stopIfRunning else false)
        """
        __systemd_unit_present "$action" "\(unit.name)" "\(stateType)" "\(daemonReload)" "\(active)" "\(autoStart)" "\(stopIfRunning)"
        """
    }
}

class UserGen extends Gen {
    user: Dynamic
    fixed id = user.id
    
    fixed result = new Listing {
        if (user.state is user.UserPresent || (user.state.hasProperty("uid") || user.state.hasProperty("shell") || user.state.hasProperty("comment")))
            let (state = user.state)
            let (uid = if (state.hasProperty("uid")) state.uid else "")
            let (gid = if (state.hasProperty("gid")) state.gid else "")
            let (comment = if (state.hasProperty("comment")) state.comment else "")
            let (home = if (state.hasProperty("home")) state.home else "/nonexistent")
            let (shell = if (state.hasProperty("shell")) state.shell else "/usr/sbin/nologin")
            """
            __user_present "$action" "\(user.name)" "\(uid)" "\(gid)" "\(comment)" "\(home)" "\(shell)"
            """
        else
            """
            __user_absent "$action" "\(user.name)"
            """
    }
}

class GroupGen extends Gen {
    group: Dynamic
    fixed id = group.id
    
    fixed result = new Listing {
        if (group.state is user.GroupPresent || (group.state.hasProperty("gid") || group.state.hasProperty("members")))
            let (state = group.state)
            let (gid = if (state.hasProperty("gid")) state.gid else "")
            let (members = if (state.hasProperty("members") && state.members != null) state.members.toList().join(",") else "")
            """
            __group_present "$action" "\(group.name)" "\(gid)" "\(members)"
            """
        else
            """
            __group_absent "$action" "\(group.name)"
            """
    }
}

local function deepToDynamic(x: base.Typed): Dynamic = x.toDynamic().toMap().mapValues((k, v) -> maybeToDynamic(v)).toDynamic()
local function maybeToDynamic(x: Any) = if (x is Typed) deepToDynamic(x) else x

const local function encodeContentBase64(content): String = 
    if (content is String) 
        content.base64
    else if (content is Resource)
        content.base64
    else if (content.url != null && content.sha256 != null)
        let (downloadedContent = read(content.url))
        let (actualHash = downloadedContent.sha256)
        if (actualHash != content.sha256)
            throw("Hash mismatch for URL \(content.url): expected \(content.sha256), got \(actualHash)")
        else
            downloadedContent.base64
    else
        throw("unsupported content: \(content)")

const local function contentSha256(content): String =
    if (content is String) 
        content.sha256
    else if (content is Resource)
        content.sha256
    else if (content.sha256 != null)
        content.sha256
    else
        throw("unsupported content: \(content)")
