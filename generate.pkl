import "package://pkl.declix.org/pkl-declix@0.3.1#/declix.pkl"
import "package://pkl.declix.org/pkl-declix@0.3.1#/apt/apt.pkl"
import "package://pkl.declix.org/pkl-declix@0.3.1#/fs/fs.pkl"

import "pkl:base"
import "pkl:math"

function generate(resources): String = gen(toGens(resources)).join("\n")

local commonSh = read("src/common.sh");

local function gen(gens: Listing<Gen>): Listing<String> = new Listing {
    // script header
    """
    #!/usr/bin/env bash
    set -eu
    set -o pipefail
    """
    commonSh.text
    // generate implementation functions
    for (gen in gens) {
        ...gen.aux
        """
        function \(gen.functionName)() {
            local action=$1
        """
        ...gen.result
        "}"
    }
    // generate check
    """
    check() {
        local status
    """
        for (gen in gens) {
            """
                status=$(\(gen.functionName) "check")
                printf "%-60s %s\\n" "\(gen.id)" "$status"
            """
        }
    "}"
    // generate diff
    """
    diff() {
        local status
    """
        for (gen in gens) {
            """
                status=$(\(gen.functionName) "diff")
                if [ -n "$status" ]; then
                    printf "\(gen.id)\\n" 
                    printf "$status\\n"
                fi
            """
        }
    "}"
    // generate apply
    """
    apply() {
        local status
    """
        for (gen in gens) {
            """
                status=$(\(gen.functionName) "apply")
                printf "%-60s %s\\n" "\(gen.id)" "$status"
            """
        }
    "}"
    // main script entrypoint
    """
    if [ $# -eq 0 ]; then
        echo "Usage: $0 {check|diff|apply}"
        exit 1
    fi
    
    action=$1
    case "$action" in
        check)
            check
            ;;
        apply)
            apply
            ;;
        diff)
            diff
            ;;
        *)
            echo "Usage: $0 {check|diff|apply}"
            exit 1
            ;;
    esac
    """
}

local function toGens(resources: Listing<Any>): Listing<Gen> = resources.toList().map((r)->toGen(r)).toListing()

local function toGen(resource: Any): Gen = 
    if (resource is apt.Package) 
        new AptPackageGen { pkg = resource }
    else if (resource is fs.File) 
        new FsFileGen { file = resource }
    else if (resource is fs.Dir) 
        new FsDirGen { dir = resource }
    else 
        throw("unsupported resource type: \(resource.type)")

abstract class Gen {
    fixed id: String

    fixed result: Listing<String>

    aux: Listing<String> = new Listing {}

    fixed functionName: String = "_" + id.replaceAll(Regex(#"[^0-9a-zA-Z_]"#), "__")
}

// each resource must define function body with following arguments:
// - $action = "check" | "apply"

class AptPackageGen extends Gen {
    pkg: apt.Package
    fixed id = pkg.id

    fixed result = new Listing { 
        if (pkg.state == "installed")
            """
            __apt_installed "$action" "\(pkg.name)" "\(pkg.updateBeforeInstall)"
            """ 
        else if (pkg.state == "missing")
            """
            __apt_missing "$action" "\(pkg.name)"
            """ 
        else
            throw("Unsupported APT package state: \(pkg.state)")
    }
}

// toList().filter((cmd) -> cmd != "").join("\n")

class FsFileGen extends Gen {
    file: fs.File
    fixed id = file.id

    fixed result = new Listing { 
        if (file.state is declix.Missing) 
            """
            __file_missing "$action" "\(file.path)"
            """ 
        else if (file.state is fs.FilePresent)
            let (state = file.state as fs.FilePresent)
            """
            __file_present "$action" "\(file.path)" "\(contentSha256(state.content))" "\(state.owner)" "\(state.group)" "\(state.permissions)"
            """ 
        else
            throw("TODO \(file.path)")
    }

    aux = if (file.state is fs.FilePresent) new Listing {
        let (content = (file.state as fs.FilePresent).content)
        """
        function __content__\(content.sha256)() {
            local content="\(encodeContentBase64(content))"
            echo $content | base64 --decode
        }
        """
    } else new Listing { }
}

class FsDirGen extends Gen {
    dir: fs.Dir
    fixed id = dir.id

    fixed result = new Listing { 
        if (dir.state is declix.Missing) 
            """
            __dir_missing "$action" "\(dir.path)"
            """ 
        else if (dir.state is fs.DirPresent)
            let (state = dir.state as fs.DirPresent)
            """
            __dir_present "$action" "\(dir.path)" "\(state.owner)" "\(state.group)" "\(state.permissions)"
            """ 
        else
            throw("TODO \(dir.path)")
    }
}

local function deepToDynamic(x: base.Typed): Dynamic = x.toDynamic().toMap().mapValues((k, v) -> maybeToDynamic(v)).toDynamic()
local function maybeToDynamic(x: Any) = if (x is Typed) deepToDynamic(x) else x

const local function encodeContentBase64(content: declix.Content): String = 
    if (content is Resource || content is String) 
        content.base64
    else if (content is declix.UrlContent)
        let (urlContent = content as declix.UrlContent)
        let (downloadedContent = read(urlContent.url))
        let (actualHash = downloadedContent.sha256)
        if (actualHash != urlContent.sha256)
            throw("Hash mismatch for URL \(urlContent.url): expected \(urlContent.sha256), got \(actualHash)")
        else
            downloadedContent.base64
    else
        throw("unsupported content: \(content)")

const local function contentSha256(content: declix.Content): String =
    if (content is Resource || content is String) 
        content.sha256
    else if (content is declix.UrlContent)
        let (urlContent = content as declix.UrlContent)
        urlContent.sha256
    else
        throw("unsupported content: \(content)")
