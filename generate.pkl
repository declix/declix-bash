import "@pkl-declix/declix.pkl"
import "@pkl-declix/apt/apt.pkl"
import "@pkl-declix/fs/fs.pkl"
import "@deepToTyped/deepToTyped.pkl"
import "pkl:base"

function generate(resources): String = gen(toGens(resources)).join("\n")

local function gen(gens: Listing<Gen>): Listing<String> = new Listing {
    // generate implementation functions
    for (gen in gens) {
        """
        function \(gen.functionName)() {
            local action=$1
        """
        ...gen.result
        "}"
    }
    // generate check function
    "check() {"
        for (gen in gens) {
            "    \(gen.functionName)) \"check\""
        }
    "}"
    // generate apply function
    "apply() {"
        for (gen in gens) {
            "    \(gen.functionName)) \"apply\""
        }
    "}"
    """
    // main script entrypoint
    action=$1
    case "$action" in
        check)
            check
            ;;
        apply)
            apply
            ;;
        *)
            echo "Usage: $0 {check|apply}"
            exit 1
            ;;
    esac
    """
}

local function toGens(resources: Listing<Any>): Listing<Gen> = resources.toList().map((r)->toGen(r)).toListing()

local function toGen(resource: Any): Gen = 
    if (resource.type == "apt") 
        new AptPackageGen { pkg = resource.toDynamic().toTyped(apt.Package) }
    else if (resource.type == "file") 
        new FsFileGen { file = deepToTyped.apply(fs.File, deepToDynamic(trace(resource))) }
    else 
        throw("unsupported resource type: \(resource.type)")

abstract class Gen {
    fixed id: String
    fixed result: Listing<String>

    fixed functionName: String = "_" + id.replaceAll(Regex(#"[^0-9a-zA-Z_]"#), "__")
}

// each resource must define function body with following arguments:
// - $action = "check" | "apply"

class AptPackageGen extends Gen {
    pkg: apt.Package
    fixed id = pkg.id

    fixed result = new Listing {
        if (pkg.updateBeforeInstall) "sudo apt update" else ""
        """
            local status=$(dpkg-query -W -f='${db:Status-Abbrev}' \(pkg.name) 2>/dev/null)
        """
        if (pkg.state == "installed") 
            """
                if [ "$status" != "ii " ]; then
                    if [ "$action" == "check" ]; then
                        echo "\(pkg.name)... missing"
                    elif [ "$action" == "apply" ]; then
                        sudo apt install -y --no-upgrade --no-install-recommends \(pkg.name)
                    fi
                else
                    echo "\(pkg.name)... ok"
                fi
            """
        else if (pkg.state == "missing") 
            """
                if [ "$status" != "" ]; then
                    if [ "$action" == "check" ]; then
                        echo "\(pkg.name)... $status"
                    elif [ "$action" == "apply" ]; then
                        sudo apt remove -y \(pkg.name)
                    fi
                else
                    echo "\(pkg.name)... ok"
                fi
            """
        else throw("unsupported pkg \(pkg.name) state: \(pkg.state)")
    }
}

// toList().filter((cmd) -> cmd != "").join("\n")

class FsFileGen extends Gen {
    file: fs.File
    fixed id = file.id

    fixed result = new Listing {
        "TODO \(file.path)"
    }
}

local function deepToDynamic(x: base.Typed): Dynamic = x.toDynamic().toMap().mapValues((k, v) -> maybeToDynamic(v)).toDynamic()
local function maybeToDynamic(x: Any) = if (x is Typed) deepToDynamic(x) else x